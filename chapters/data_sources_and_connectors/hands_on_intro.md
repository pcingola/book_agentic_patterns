## Hands-On: Introduction

The exercises that follow put the connector patterns from this chapter into practice across three distinct data source types: files, SQL databases, and controlled vocabularies. Each exercise builds a working agent that interacts with real data through connector methods exposed as tools, demonstrating different patterns for managing runtime context (contextvars for user/session isolation, closures for database binding), workspace-based persistence for decoupling agents, and strategy-based dispatch for handling different backend characteristics.

The first exercise uses the FileConnector to give an agent basic filesystem operations -- creating, reading, and editing files through sandbox-isolated paths. The second exercise chains two agents together: an NL2SQL agent translates a natural language question into validated SQL, executes it against a bookstore database, and saves the results as a CSV file; a second agent then picks up that CSV using the CsvConnector and inspects it independently. The workspace filesystem acts as the integration layer between them, illustrating how connectors compose without the agents needing any knowledge of each other. The third exercise introduces the VocabularyConnector, which resolves free-text terms into standardized codes using two different strategies -- an in-memory tree with exact and fuzzy matching for smaller vocabularies, and a vector-database-backed semantic search for larger ones. Both strategies share the same interface, so the agent tools work identically regardless of which backend handles a given vocabulary.

Taken together, these exercises reinforce the chapter's central argument: connectors are framework-agnostic abstractions that define what operations an agent can perform, while tools are thin wrappers that make those operations discoverable by a specific runtime. The code stays testable, portable, and reusable because the data-access logic never depends on the agent framework.
